\documentclass[compsoc,conference,a4paper,10pt,times]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{bmpsize}
\usepackage{xcolor}
\usepackage{lipsum}
%\usepackage{minted}
\usepackage[colorlinks=true,urlcolor=black]{hyperref}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Machine Checked Properties of the Schulze Method}

\author{\IEEEauthorblockN{Mukesh Tiwari}
\IEEEauthorblockA{\textit{ School of Computing and Information Systems} \\
\textit{University of Melbourne}\\
Melbourne, Australia \\
mukesh.tiwari@unimelb.edu.au}
\and
\IEEEauthorblockN{Dirk Pattinson}
\IEEEauthorblockA{\textit{Research School of Computer Science} \\
\textit{Australian National University}\\
Canberra, Australia\\
dirk.pattinson@anu.edu.au}
}

\maketitle

\begin{abstract}
The correctness of electronic vote-counting software programs is 
crucial in establishing the trust of people in electronic voting. 
However, most of these vote-counting programs, used in 
various jurisdiction for legally binding election, establish
the correctness by means of testing which is not sufficient and leaves much to be desired. 
Therefore, we propose that legally binding vote-counting software 
programs should be formally verified and its correctness should be 
evaluated against some well established framework from social choice theory, 
e.g., one 
such framework for preferential voting methods is Arrow's Impossibility 
Theorem.

In this work, 
we formally prove (machine-checked) that our Coq implementation of the Schulze method,
a preferential voting method, 
follows the Condorcet winner property. We leave the formal machine-checked proof of 
other properties, e.g., reversal symmetry, Pareto, monotonicity, etc., for future work. 
This is, to the best of our knowledge, the first machine-checked proof of 
properties of the Schulze method implementation, and in fact, any preferential vote-counting 
implementation. 


\end{abstract}

\begin{IEEEkeywords}
formal method, electronic voting, Schulze method, 
Condorcet winner, Coq theorem prover
\end{IEEEkeywords}

 
\section{Introduction}
    The Schulze method \cite{Schulze:2011:NMC}, a preferential voting method, in the recent year 
    has gained a lot of popularity in electing the candidates of many open source 
    software communities, Wikipedia, and the Pirate Party of various countries, as of the writing it 
    is used by more  than  60 organizations  with  more  than  900,000  eligible  
    members  in  total \cite{schulze2020schulze}. One particular reason for this popularity is that it 
    has a lot of nice properties, from social choice theory perspective, and many of 
    these important properties are already established in the Schulze's original paper \cite{Schulze:2011:NMC}, e.g., Condorcet winner, Pareto, reversal symmetry, monotonicty, 
    etc. Moreover, it fails on independence of 
    irrelevant alternatives (IIA) criterion, a consequence of the impossibility theorem \cite{arrow1950difficulty} which states that no preferential voting 
    method can have all the properties. 

    In this work, we establish that our implementation of Schulze method \cite{Pattinson:2017:SVE}
    follows Condorcet winning criterion. It is ongoing work and in  
    future, we would like to establish that our implementation follows all the other properties, 
    e.g. reversal symmetry, Pareto, monotonicity, etc. 
    More importantly, it would be interesting to establish that our implementation 
    fails on IIA criterion. The 
    source code for this ongoing work can be accessed from the GitHub 
    repo\footnote{\url{https://github.com/mukeshtiwari/Schulzeproperties/blob/master/Schulzeprop.v}}
    
    \section{Schulze Method}
    In this section, we give a brief overview of the Schulze method and 
    necessary formalisation details to make it self-contained. However, we invite the 
    curious reader to read our paper \cite{Pattinson:2017:SVE} for more details. 
    
    
    The  method itself rests on the relative margins between two candidates, i.e. the number of voters that prefer one candidate over another. The margin induces an ordering between candidates, where a candidate c is more preferred than d, if more voters prefer c over d than vice versa. One can construct simple examples (see e.g. \cite{Rivest:2010:OSW}) where this order does not have 
    a maximal element (a so-called Condorcet Winner). Schulzeâ€™s observation is that this 
    ordering can be made transitive by considering sequences of candidates (called paths). 
    Given candidates c and d, a path between c and d is a sequence of candidates 
    $p= (c,c_{1}, \dots ,c_{n},d)$ that joins c and d, and the strength of a path is the 
    minimal margin between adjacent nodes. This induces the generalised margin between 
    candidates c and d as the strength of the strongest path that joins c and d. 
    A candidate c then wins a Schulze count if the generalised margin between c 
    and any other candidate d is at least as large as the generalised margin between d and c.
    In more detail:

\begin{enumerate}  

\item Consider an election with a set of $t$ candidates
    $C$ = $\{c1,\dots,ct\}$ and 
	a set of $n$ votes $P$ = $\{b1,\dots,bn\}$. A vote
	is represented as a function $b: C \rightarrow \mathbb{N}$ that 
	assigns natural 
	number (the preference) to each candidate. 
	We recover a strict total 
	preorder $<_b$ on the candidates by setting $c <_b d$ if $b(c) > b(d)$, i.e. 
	candidate $c$ is less preferred over candidate $d$ if the natural number $b(c)$ is greater
	than the natural number $b(d)$. 
	
\item We construct a margin matrix $marg : C \times C \to \mathbb{Z}$ as follows: 
    given two candidates $c, d \in C$, the \emph{margin} of $c$ over $d$ is
    the number of voters that prefer $c$ over $d$ minus the number of voters
    that prefer $d$ over $c$. In symbols:
\[
  marg (c, d) = \sharp \lbrace b \in P \mid c >_b d \rbrace -
            \sharp \lbrace b \in P \mid d >_b c \rbrace
\] where $\sharp$ denotes cardinality.


\item A directed \emph{path} from
candidate $c$ to candidate $d$ is a sequence $p \equiv c_0, \dots, c_{w+1}$
of candidates with $c_0 = c$ and $c_{w+1} = d$ ($w \geq 0$), and the
\emph{strength}, $st$, of path $p$ is the minimum margin of adjacent
nodes, i.e.
\[ st(c_0, \dots, c_{w+1}) = \min \lbrace marg (c_i, c_{i+1}) \mid 0 
\leq i \leq w \rbrace. \]
\item  A generalised margin matrix, $M$, denote the strength of the strongest path
	between two candidates, i.e. 
	\[ M(c, d) = \max \lbrace st (p) : p \text{ is path from } c \text{ to } d\rbrace \]
	
\item The winning set  is defined as 
 \[ W =  \lbrace c \in C : \forall d \in C \setminus \{c\}, M (c, d) \geq M (d, c) \rbrace\]

\end{enumerate}


Our Coq formalisation models candidates as Type. Moreover, it postulates that the candidates 
are finite and non-empty with decidable equality. For our purpose, 
the easiest way of stipulating that a type be finite is to require existence of a 
list containing all inhabitants of this type \cite{10.1145/2808098.2808102}.

 \begin{minted}{coq}
Parameter cand : Type.
Parameter cand_all : list cand.
Hypothesis cand_fin : 
 forall c: cand, In c cand_all.
Hypothesis cand_not_nil : 
 cand_all <> nil.
Hypothesis dec_cand : 
 forall n m : cand, {n = m} + {n <> m}.


\end{minted}


We define a boolean value function (step 5) that determines 
(the Schulze) election winners based on 
the generalised margin matrix (step 4). ($M \text{ } marg \text{ } 
(length \text{ } cand\_all) \text{ } c \text{ } d$ 
in the $schulze\_winner$ definition is Coq encoding of the generalised margin matrix, 
$M \text{ } (c, \text{ }d)$, defined in step 4. The syntactic differences do not matter 
for this discussion.)
 \begin{minted}{coq}
Definition schulze_winner 
  (marg : cand * cand -> Z) 
  (c : cand) := forallb (fun d => 
  (M marg (length cand_all) d c) <=? 
  (M marg (length cand_all) c d))
  cand_all.
\end{minted}


\section{Properties of Schulze Method}
	 We have a boolean function,  \textit{schulze\_winner},  that 
	 elects the winner,  the key question is that how do we know that 
	 this winner is indeed the real winner,  intended by the voters, and 
	 not because of the software bug in the implemetation.  In our 
	 original paper, we have given two definitions of 
	 winners, one in Prop (logical) and one in Type (computational) and 
	 proved that both implemetations are equivalent. 
	  
\begin{minted}{coq}
Definition wins_prop (c: cand) : Prop := 
 forall d: cand, exists k: Z,
  Path k c d /\ 
 (forall l, Path l d c -> l <= k)
	 
Definition wins_type c : Type :=
 forall d : cand, existsT (k : Z),
 ((PathT k c d) *
  (existsT (f : (cand * cand) -> bool), 
  f (d, c) = true /\ coclosed (k + 1) f))
  
Lemma wins_prop_type : forall c, 
 wins_prop c -> wins_type c.
Proof.  (* proof terms omitted *) Qed. 

Lemma wins_type_prop : forall c, 
 wins_type c -> wins_prop c.  
Proof.  (* proof terms omitted *) Qed. 	 
\end{minted}

At this point, the curious author would be wondering why do we 
need to have two definitions for the same thing, but one thing 
she would definately agree that the defintion of \textit{wins\_prop} is easier to 
inspect and understand compared to the definition of \textit{wins\_type}.
  The goal 
of our formalisation was two fold: i) extracting an OCaml 
code from it and using the OCaml code 
to count the ballots from real world elections and ii)
making it accessble to everyone.  To achieve the 
first goal, we defined a (complicated) definition in Type 
and for the secod goal, we defined a (simple) definition in Prop. 
All the reader has to do is inspect the simple logical defintion 
\textit{wins\_prop} to ensure that it correctly captures the notion 
of winner,  without understanding the the complicated computable 
definition of \textit{wins\_type}.  The proof that these two definitions 
are equivalent is delegated to the Coq theorem prover, so the reader 
has to do is replay the proofs of  \textit{wins\_prop\_type} and 
\textit{wins\_type\_prop}.  Coq's extraction mechanism erases all the (logical) terms in sort Prop while 
keeps all the (computational) terms in sort Type. 


 \subsection{Condorcet Winner}
	A \textit{Condorcet winner} is a candidate who beats every other candidate in a 
	pairwise comparison, also known as head to head competition. 
	Recall from the previous section that the margin matrix, $marg$, 
	stores exactly this data for every pair of candidates.
	Therefore, we define the Condorcet winner in Coq:

\begin{minted}{coq}
Definition condorcet_winner 
 (marg : cand * cand -> Z) 
 (c : cand) := forall d, 
 marg (c, d) >= 0.
\end{minted}

  Informally, the definition,  $condorcet\_winner$, states that 
  if a candidate $c$  is the Condorcet winner, then she is
  ranked equal or higher against
  every other candidate in more ballots than vice versa. 
  Now, our goal is to concluded that if there is a 
  Condorcet winner, then the Schulze method
  elects it. We formally state our intent 
  in Coq as:
 	
\begin{minted}{coq}
 Lemma condorcet_winner_implies_winner 
    (marg : cand * cand -> Z)
    (c : cand) : 
    condorcet_winner marg c -> 
    schulze_winner marg c = true. 
Proof.
  (* proof terms omitted *)
Qed.
\end{minted}

  		
 The proof of $condorcet\_winner\_implies\_winner$ hinges on the two key observations:
 
 \begin{enumerate}
  \item If a candidate $c$ is the Condorcet winner, then the generalised margin (matrix) 
  between $c$
  and every other candidate, say, $d$ would be greater than or equal to 0, i.e. 
  $M \text{ } (c, \text{ }d) \geq 0$.
  
  \item If a candidate $c$ is the Condorcet winner, then the generalised margin  (matrix)
  between every other candidate, say, $d$ and $c$ would be less than or equal to 0, 
  $M \text{ } (d, \text{ }c) \leq 0$.
 \end{enumerate}
 
 
 These two key observations make the proof of the lemma $condorcet\_winner\_implies\_winner$ 
 trivial because we have $M \text{ } (d, \text{ }c) \leq 0$  and
  $M \text{ } (c, \text{ }d) \geq 0$, hence $M \text{ } (d, \text{ }c)  \leq 
   M \text{ } (c, \text{ }d)$. Intuitively, 
 if a candidate $c$ is the Condorcet winner, then the strongest path between her and every other 
 candidate, say, $d$ would be either a direct path or a more stronger path 
 via some other intermediate candidates (proof by induction on the path length). 
 In both cases, we have the generalised margin between 
 $c$ and the other candidate $d$ is greater than or equal to 0. 
 Similarly, for the second observation. We encode these two key observations in 
 Coq:
 
 \begin{minted}{coq}
Lemma first_key_observation : 
 forall c d n marg, 
 condorcet_winner c marg -> 
 M marg n c d >= 0.
Proof.
  (* proof terms omitted *)
Qed.

Lemma second_key_observation : 
 forall c d n marg, 
 condorcet_winner c marg -> 
 M marg n d c <= 0.
Proof.
  (* proof terms omitted *)
Qed. 
 \end{minted}

Proof of the last two lemmas is by induction on the path length, i.e. n \cite{Carre:1971:ANR}. 







\subsection{Reversal Symmetry\footnote{It is not complete and still ongoing.}}
 The \textit{Reversal symmetry} is a voting method criterion which states that if the
 voting method has produced a unique 
  winner, say, $c$ based on the cast ballots, then $c$ should not be elected if the 
 individual choices were reversed. 
 In context of Schulze method, we first need to define the unique winner, and ballot reversal. 
 
 \begin{minted}{coq}
 Definition unique_winner 
 (marg : cand * cand -> Z) 
 (c : cand) :=
 schulze_winner marg  c = true /\
 (forall d, d <> c -> 
  schulze_winner marg d = false).
\end{minted}  
\noindent
Informally, the definition of \textit{unique\_winner} states that a 
candidate $c$ is a unique winner
if it wins the election and every candidate 
other than $c$ loses the election.
We capture the ballot reversal in terms of margin matrix. For any given ballot set $P$, 
the margin between two candidates $c$ and $d$ is: 
\[
  marg(c, d) = \sharp \lbrace b \in P \mid c >_b d \rbrace -
            \sharp \lbrace b \in P \mid d >_b c \rbrace
\] 

\noindent
If we reverse the individual choices in every ballot, the new margin matrix, denoted as $rev\_marg$, would be:

\[
  rev\_marg(c, d) = -1 * marg (c, d)  
\]    

\noindent
The connection between $rev\_marg$ and $marg$ is very intuitive, but it can be understood 
by considering a hypothetical single ballot election. Let's assume that we have 
a single ballot $(A, 1); (B, 2); (C, 3)$ and the interpretation is 
that $A$ is strictly preferred over $B$, and $B$ is strictly preferred over $C$ 
(but we do not need strict preferences to have this property).  The margin matrix
constructed from this ballot is: 

\[
\bordermatrix{ & A & B & C \cr
      A & 0 & 1 & 1 \cr
      B & -1 & 0 & 1 \cr
      C & -1 & -1 & 0 }
      \]
    
\noindent      
After reversing the original ballot, we get $(A, 3); (B, 2); (C, 1)$ and 
the margin matrix is:
\[
\bordermatrix{ & A & B & C \cr
      A & 0 & -1 & -1 \cr
      B & 1 & 0 & -1 \cr
      C & 1 & 1 & 0 }
      \]


\noindent
It is clearly evident from this example that the 
connection between $rev\_marg$ and $marg$  holds.
We capture this connection in Coq as:

\begin{minted}{coq}
Definition rev_marg 
   (marg : cand -> cand -> Z) 
   (c d : cand) := -marg c d.
\end{minted}

\noindent


Finally, the reversal symmetry property can be expressed in Coq as: 
\begin{minted}{coq}
Lemma reversal_symmetry : forall marg c, 
  unique_winner marg c ->
  schulze_winner (rev_marg marg) c = 
  false.
Proof. 
 (* still ongoing *)
\end{minted}

\noindent
The lemma $reversal\_symmetry$ expresses that if a candidate $c$ is the unique 
winner, with respect to $marg$ computed from some ballot set $P$, then she is 
a loser with respect to $rev\_marg$, computed from reversing all the entries 
in the ballot set $P$.

\noindent
The proof this lemma is fairly straight forward \cite{Schulze:2011:NMC}, but 
the (Schulze's) paper assumes a key property which turns out to be very difficult to prove, 
at least in our encoding, in Coq. The key property is: if $M$ 
is the generalised margin 
matrix (step 4), computed using the margin matrix $marg$ and $M\_rev$ is the generalised 
margin matrix, computed using the margin matrix $rev\_marg$, then 
$M\_M\_rev: \forall \text{ } c \text{ } d,  M(c, d) = M\_rev (d, c)$ holds. Currently, 
we do not have the proof of $M\_M\_rev$ in Coq, but we managed to prove 
another property, $path\_with\_rev\_marg$, that can be combined with 
some other properties to complete the proof of $M\_M\_rev$. 

\begin{minted}{coq}
Lemma path_with_rev_marg :
  forall k marg c d,
  Path marg k c d <->  
  Path (rev_marg marg) k d c.
Proof.
(* proof terms omitted *)  
Qed.
\end{minted}

\noindent
$Path$ is an inductive datatype that exactly captures the notion of 
sequence of nodes between two candidates (step 3). More elaborately, 
$Path \text{ }k \text{ }marg \text{ }c \text{ }d$ a path $p$, sequence of candidates 
$p= (c,c_{1}, \dots ,c_{w},d)$, that joins c and d and the strength of 
p, $st(p) =  \min \lbrace marg (c_i, c_{i+1}) \mid 0 
\leq i \leq w \rbrace$, is greater than or equal to $k$. 

\noindent
The lemma $path\_with\_rev\_marg$ states that if there is a path from 
$c$ to $d$ of strength $k$, with respect to $marg$, then we have 
a path of same strength $k$ from $d$ to $c$, with respect to $rev\_marg$. 
If this path from $c$ to $d$ happens to be the strongest path (step 4), 
then we can prove $M\_M\_rev$.\footnote{The challenge in our encoding 
is proving that the strength of the strongest path is $\geq  M(c, d)$ and 
the strength of all paths is $\leq M(c, d)$ to infer the equality, 
i.e. strength of the strongest path $= M(c, d)$}

\bibliography{thesis}
\bibliographystyle{IEEEtran}

\end{document}
